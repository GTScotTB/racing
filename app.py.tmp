from flask import Flask, render_template, jsonify, request, flash, redirect, url_for, session
from config import SQLALCHEMY_DATABASE_URI, SQLALCHEMY_TRACK_MODIFICATIONS
from models import db,User, Entry, InspectionChecklist, InspectionItem, ChecklistItem, Officials, Roles, FormulaFordEvent, FormulaFordEventEntry, FormulaFordTechnicalCheck, FormulaFordTyreCheck, TimetableSession, FormulaFordCompetitor, EventTechnicalRequirements, CompetitorTechnicalRecord, EventTyreRequirements, CompetitorTyreRecord
from sqlalchemy import or_, func, Integer, text, case, desc
from flask_migrate import Migrate
import os
from datetime import datetime, timezone, timedelta
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from functools import wraps
from auth import check_password, hash_password
import csv
import io
import json
# Reimport Flask-WTF CSRF protection
from flask_wtf.csrf import CSRFProtect, generate_csrf, validate_csrf, CSRFError
import traceback
from werkzeug.security import generate_password_hash, check_password_hash
from urllib.parse import urlparse
import re
import uuid

# Initialize Flask app
app = Flask(__name__, template_folder='templates')
app.config['SECRET_KEY'] = 'yoursecretkey'  # Replace with a real secret key
app.config['SQLALCHEMY_DATABASE_URI'] = SQLALCHEMY_DATABASE_URI
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = SQLALCHEMY_TRACK_MODIFICATIONS

# Additional security configurations for session handling
app.config['SESSION_COOKIE_SECURE'] = False  # Set to True if using HTTPS
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=1)  # Session timeout
app.config['WTF_CSRF_TIME_LIMIT'] = 3600  # Increase CSRF token timeout to 1 hour
app.config['WTF_CSRF_SSL_STRICT'] = False  # Less strict CSRF checks for development

# Make sessions last longer
@app.before_request
def make_session_permanent():
    session.permanent = True  # Use the PERMANENT_SESSION_LIFETIME value

# Enable CSRF protection
# This ensures all POST, PUT, PATCH, and DELETE requests require a valid CSRF token
csrf = CSRFProtect(app)

# CSRF Error Handler - Register this immediately after creating csrf
@app.errorhandler(CSRFError)
def handle_csrf_error(e):
    print(f"CSRF ERROR: {str(e)}")
    print(f"Current session: {session}")
    print(f"Request cookies: {request.cookies}")
    flash("CSRF token validation failed. Please try again.", "danger")
    return redirect(url_for('login'))

# Make CSRF token available in all templates
# This function adds csrf_token to the context of all templates
@app.context_processor
def inject_csrf_token():
    token = generate_csrf()
    # Add debugging for token generation
    print(f"Generated CSRF token: {token}")
    return dict(csrf_token=token)

# Login Manager
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'  # Redirect to login page if not authenticated
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))  # Fetch user by ID

# Initialize SQLAlchemy with Flask
db.init_app(app)

# Initialize Flask-Migrate
migrate = Migrate(app, db)

# Enable Foreign Key Constraints in SQLite
@app.before_request
def enable_foreign_keys():
    if 'sqlite' in SQLALCHEMY_DATABASE_URI:
        with db.engine.connect() as connection:
            connection.execute(text("PRAGMA foreign_keys=ON"))

# admin required decorator
def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or current_user.role.lower() != 'admin':
            flash('You do not have permission to access this page.', 'danger')
            return redirect(url_for('wtac_dashboard'))
        return f(*args, **kwargs)
    return decorated_function
 

# Route: Login (GET AND POST)
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        print("\n=== LOGIN DEBUG START ===")
        print("LOGIN: POST request received")
        print(f"LOGIN: Form data: {request.form}")
        
        try:
            # CSRF protection is handled by CSRFProtect(app) automatically
            # We don't need to manually validate the token
            username = request.form['username']
            print(f"LOGIN: Username: {username}")
            
            plain_password = request.form['password']
            print("LOGIN: Password received (not logging actual value)")
            
            user = User.query.filter_by(username=username).first()
            print(f"LOGIN: User found: {user is not None}")

            if not user:
                print("LOGIN: User not found")
                flash("Invalid username or password.", "danger")
                return redirect(url_for('login'))
                
            password_match = check_password(plain_password, user.password)
            print(f"LOGIN: Password check result: {password_match}")
            
            if password_match:
                print(f"LOGIN: Login successful for user: {username}")
                login_user(user)
                next_page = request.args.get('next')
                if next_page:
                    print(f"LOGIN: Redirecting to next page: {next_page}")
                    print("=== LOGIN DEBUG END ===\n")
                    return redirect(next_page)
                
                # Check user role and redirect accordingly
                if user.role.lower() == 'admin':
                    print(f"LOGIN: Admin user detected, redirecting to index page")
                    print("=== LOGIN DEBUG END ===\n")
                    return redirect(url_for('index'))
                else:
                    print(f"LOGIN: Regular user detected, redirecting to WTAC dashboard")
                    print("=== LOGIN DEBUG END ===\n")
                    return redirect(url_for('wtac_dashboard'))
            else:
                print("LOGIN: Password mismatch")
                flash("Invalid username or password.", "danger")
                print("=== LOGIN DEBUG END ===\n")
                return redirect(url_for('login'))
                
        except Exception as e:
            print(f"LOGIN ERROR: {str(e)}")
            print("Exception traceback:")
            traceback.print_exc()
            flash(f"Error during login: {str(e)}", "danger")
            print("=== LOGIN DEBUG END ===\n")
            return redirect(url_for('login'))
    
    # For GET requests
    print("\n=== LOGIN GET DEBUG ===")
    print("LOGIN: GET request - rendering login template")
    print(f"LOGIN: Current session: {session}")
    print("=== LOGIN GET DEBUG END ===\n")
    
    return render_template('login.html')

# Route: Logout
@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('index'))  # Keep this redirecting to index (home page)

# Route: Home 
@app.route('/')
@login_required
def index():
    return render_template('index.html')  # Render the new index page with two buttons

# Route: WTAC Dashboard
@app.route('/wtac_dashboard')
@login_required
def wtac_dashboard():
    user_role = current_user.role  # Get the role of the logged-in user
    return render_template('wtac_dashboard.html', user=current_user, role=user_role)  # Render the WTAC dashboard

# Route: Formula Ford Dashboard
@app.route('/formula_ford/dashboard')
@login_required
def formula_ford_dashboard():
    events = FormulaFordEvent.query.order_by(FormulaFordEvent.round_number).all()
    return render_template('formula_ford_dashboard.html', events=events)

# Route: Register
@app.route('/register')
def register():
    return render_template('register.html')

# Route: Add Entry (GET)
@app.route('/add_entry', methods=['GET'])
@login_required
def show_add_entry():
    # Define valid classes or fetch them from your system
    classes = [
        "Tuner", "Clubsprint", "Open", "Pro Open",
        "Pro Am", "Pro", "Flying 500", "Demo"
    ]
    return render_template('add_entry.html', classes=classes)  # Pass classes to the template

# Route: Add Entry (POST)
@app.route('/add_entry', methods=['POST'])
@login_required
def add_entry():
    # Extract data from the form
    vehicle_number = request.form.get('vehicle_number')
    vehicle_make = request.form.get('vehicle_make')
    vehicle_model = request.form.get('vehicle_model')
    garage_number = request.form.get('garage_number')
    log_book_number = request.form.get('log_book_number')
    licence_number = request.form.get('licence_number', '000000')
    driver_name = request.form.get('driver_name')
    class_type = request.form.get('class')
    normalized_class_type = class_type.replace(' ', '_').lower()
    action = request.form.get('action')  # Capture the action (add or add_and_inspect)

    # Check mandatory fields
    if not vehicle_number or not vehicle_make or not driver_name or not class_type:
        return render_template('add_entry.html', error="Please fill in all required fields.")

    # Create a new Entry object
    new_entry = Entry(
        vehicle_number=vehicle_number,
        vehicle_make=vehicle_make,
        vehicle_model=vehicle_model,
        garage_number=garage_number,
        log_book_number=log_book_number,
        licence_number=licence_number,
        driver_name=driver_name,
        class_type=normalized_class_type
    )

    try:
        # Add the entry to the database
        db.session.add(new_entry)
        db.session.commit()

        # Handle the "Add Entry and Inspect" action
        if action == "add_and_inspect":
            # Generate a checklist for the new entry
            checklist = InspectionChecklist(entry_id=new_entry.id)
            db.session.add(checklist)
            db.session.commit()

            # Dynamically generate inspection items from checklist_items
            applicable_items = ChecklistItem.query.filter(
                getattr(ChecklistItem, f"applicable_to_{new_entry.class_type.lower()}") == True
            ).all()

            for item in applicable_items:
                new_item = InspectionItem(
                    checklist_id=checklist.id,
                    item_name=item.item_name,
                    brand_required=item.brand_required,
                    standard_required=item.standard_required,
                    expiry_date_required=item.expiry_date_required,
                    rops_required=item.rops_required
                )
                db.session.add(new_item)

            db.session.commit()

            # Redirect to the checklist page
            return redirect(url_for('view_checklist', checklist_id=checklist.id))

        # Handle the "Add Entry" action
        return render_template('index.html', success="Entry added successfully!")

    except Exception as e:
        print(f"Error adding entry: {e}")
        return render_template('add_entry.html', error="Failed to add entry. Please try again.")
    
# Route: Lookup Entry (GET)
@app.route('/lookup_entry', methods=['GET'])
@login_required
def lookup_entry():
    search_query = request.args.get('search_query', '').strip()

    if search_query:
        # Fetch entries matching the search query
        results = db.session.query(
            Entry.id,
            Entry.driver_name,
            Entry.vehicle_number,
            Entry.vehicle_make,
            Entry.vehicle_model,
            Entry.class_type,
            Entry.garage_number
        ).filter(
            or_(
                Entry.driver_name.ilike(f"%{search_query}%"),
                Entry.vehicle_number.ilike(f"%{search_query}%"),
                Entry.vehicle_make.ilike(f"%{search_query}%"),
                Entry.vehicle_model.ilike(f"%{search_query}%")
            )
        ).order_by(
            func.cast(
                func.substr(
                    Entry.vehicle_number,
                    1,
                    func.instr(Entry.vehicle_number + 'A', 'A') - 1
                ),
                Integer
        )
    ).all()
    else:
        results = []

    # Render the template and pass the results
    return render_template('lookup_entry.html', results=results, search_query=search_query)

# Route: Lookup Entry2 (GET)
@app.route('/lookup_entry2', methods=['GET'])
@login_required
# This route is similar to lookup_entry but its for loaded the button stye view page
def lookup_entry2():
    search_query = request.args.get('search_query', '').strip()

    if search_query:
        # Fetch entries matching the search query
        results = db.session.query(
            Entry.id,
            Entry.driver_name,
            Entry.vehicle_number,
            Entry.vehicle_make,
            Entry.vehicle_model,
            Entry.class_type,
            Entry.garage_number
        ).filter(
            or_(
                Entry.driver_name.ilike(f"%{search_query}%"),
                Entry.vehicle_number.ilike(f"%{search_query}%"),
                Entry.vehicle_make.ilike(f"%{search_query}%"),
                Entry.vehicle_model.ilike(f"%{search_query}%")
            )
        ).order_by(
    func.cast(
        func.substr(
            Entry.vehicle_number,
            1,
            func.instr(Entry.vehicle_number + 'A', 'A') - 1
        ),
        Integer
    )
).all()
    else:
        results = []

    # Render the template and pass the results
    return render_template('lookup_entry2.html', results=results, search_query=search_query)


# Route: View Checklist (GET & POST)
@app.route('/view_checklist', methods=['GET', 'POST'])
@login_required
def view_checklist():
    scrutineers = Officials.query.filter_by(role="Scrutineer").all()

    if request.method == 'POST':
        entry_id = request.form.get('entry_id')  # Get entry_id from the form
        print(f"Received entry_id: {entry_id}")  # Debugging

        entry = db.session.get(Entry, entry_id)  # Retrieve the entry
        if not entry:
            return jsonify({'error': "Entry not found!"}), 404

        print(f"Found entry: {entry}")  # Debugging

        # Check if a checklist exists for this entry
        checklist = InspectionChecklist.query.filter_by(entry_id=entry.id).first()

        if not checklist:
            print("No checklist found. Creating a new checklist.")  # Debugging

            # Create a new checklist
            checklist = InspectionChecklist(entry_id=entry.id)
            db.session.add(checklist)
            db.session.commit()

            # Dynamically generate inspection items for this checklist
            applicable_items = ChecklistItem.query.filter(
                getattr(ChecklistItem, f"applicable_to_{entry.class_type.lower()}") == True
            ).all()

            for item in applicable_items:
                new_item = InspectionItem(
                    checklist_id=checklist.id,
                    item_name=item.item_name,
                    brand_required=item.brand_required,
                    standard_required=item.standard_required,
                    expiry_date_required=item.expiry_date_required,
                    rops_required=item.rops_required
                )
                db.session.add(new_item)

            db.session.commit()

        # Retrieve checklist items for rendering
        items = InspectionItem.query.filter_by(checklist_id=checklist.id).all()
        print(f"Checklist ID: {checklist.id}, Number of items: {len(items)}")  # Debugging

        return render_template('checklist.html', checklist=checklist, items=items, entry=entry, scrutineers=scrutineers, current_date=datetime.now().strftime('%Y-%m-%d'), current_time=datetime.now().strftime('%H:%M:%S'))

    elif request.method == 'GET':
        checklist_id = request.args.get('checklist_id')  # Get checklist_id from query parameters
        checklist = db.session.get(InspectionChecklist, checklist_id)

        if not checklist:
            return jsonify({'error': "Checklist not found!"}), 404

        # Fetch associated entry
        entry = Entry.query.get(checklist.entry_id)
        items = InspectionItem.query.filter_by(checklist_id=checklist.id).all()
       

        return render_template(
            'checklist.html',
            checklist=checklist,
            items=items,
            entry=entry,
            scrutineers=scrutineers,
            current_date=datetime.now().strftime('%Y-%m-%d'),
            current_time=datetime.now().strftime('%H:%M:%S')
        )

# Route: View Checklist2 (GET & POST)
@app.route('/view_checklist2', methods=['GET', 'POST'])
@login_required
def view_checklist2():
    user_role = current_user.role
    scrutineers = Officials.query.filter_by(role="Scrutineer").all()

    if request.method == 'POST':
        # Handle POST request: Create or fetch checklist based on entry_id
        entry_id = request.form.get('entry_id')  # Get entry_id from the form
        print(f"Received entry_id: {entry_id}")  # Debugging

        entry = db.session.get(Entry, entry_id)  # Retrieve the entry
        if not entry:
            return jsonify({'error': "Entry not found!"}), 404

        print(f"Found entry: {entry}")  # Debugging

        # Check if a checklist exists for this entry
        checklist = InspectionChecklist.query.filter_by(entry_id=entry.id).first()

        if not checklist:
            print("No checklist found. Creating a new checklist.")  # Debugging

            # Create a new checklist
            checklist = InspectionChecklist(entry_id=entry.id)
            db.session.add(checklist)
            db.session.commit()

            # Dynamically generate inspection items for this checklist
            applicable_items = ChecklistItem.query.filter(
                getattr(ChecklistItem, f"applicable_to_{entry.class_type.lower()}") == True
            ).all()

            for item in applicable_items:
                new_item = InspectionItem(
                    checklist_id=checklist.id,
                    item_name=item.item_name,
                    brand_required=item.brand_required,
                    standard_required=item.standard_required,
                    expiry_date_required=item.expiry_date_required,
                    rops_required=item.rops_required
                )
                db.session.add(new_item)

            db.session.commit()

        # Retrieve checklist items for rendering
        items = InspectionItem.query.filter_by(checklist_id=checklist.id).all()
        print(f"Checklist ID: {checklist.id}, Number of items: {len(items)}")  # Debugging

        return render_template(
            'checklist2.html',
            checklist=checklist,
            items=items,
            entry=entry,
            scrutineers=scrutineers,
            current_date=datetime.now().strftime('%Y-%m-%d'),
            current_time=datetime.now().strftime('%H:%M:%S')
        )

    elif request.method == 'GET':
        # Handle GET request: Fetch checklist based on checklist_id
        checklist_id = request.args.get('checklist_id')  # Get checklist_id from query parameters
        checklist = InspectionChecklist.query.get(checklist_id)

        if not checklist:
            return jsonify({'error': "Checklist not found!"}), 404

        # Fetch associated entry
        entry = Entry.query.get(checklist.entry_id)
        items = InspectionItem.query.filter_by(checklist_id=checklist.id).all()

        return render_template(
            'checklist2.html',
            checklist=checklist,
            items=items,
            entry=entry,
            scrutineers=scrutineers,
            current_date=datetime.now().strftime('%Y-%m-%d'),
            current_time=datetime.now().strftime('%H:%M:%S'),
            user=current_user, role=user_role
        )    
# route: update checklist 2

@app.route('/update_checklist2', methods=['POST'])
@login_required

def update_checklist2():
    user_role = current_user.role
    print(request.form)  # Debug submitted form data
    try:
        checklist_id = request.form.get('checklist_id')
        checklist_items = InspectionItem.query.filter_by(checklist_id=checklist_id).all()

        vehicle_approved = False  # Initialize approval status

        # Use no_autoflush from the session
        with db.session.no_autoflush:
            for item in checklist_items:
                # Handle special items separately
                if item.item_name in ["Vehicle Weight", "Time", "Date", "Scrutineer Name", "Scrutineer Licence Number"]:
                    if item.item_name == "Vehicle Weight":
                        vehicle_weight = request.form.get(f'vehicle_weight_{item.id}')
                        if vehicle_weight:
                            item.value = vehicle_weight
                    elif item.item_name == "Time":
                        time_value = request.form.get('time')
                        if time_value:
                            item.value = time_value
                    elif item.item_name == "Date":
                        date_value = request.form.get('date')
                        if date_value:
                            item.value = date_value
                    continue  # Skip the rest of the loop for these items

                # Update the status from the form data
                status = request.form.get(f'status_{item.id}')
                if status:
                    item.status = status

                # Conditionally update extra fields based on item requirements
                if item.brand_required:
                    item.brand = request.form.get(f'brand_{item.id}')
                if item.standard_required:
                    item.standard = request.form.get(f'standard_{item.id}')
                if item.expiry_date_required:
                    expiry_date_value = request.form.get(f'expiry_date_{item.id}')
                    if expiry_date_value:
                        # Convert the string to a Python date object
                        item.expiry_date = datetime.strptime(expiry_date_value, '%Y-%m-%d').date()
                    else:
                        item.expiry_date = None
                if item.rops_required:
                    item.rops = request.form.get(f'rops_{item.id}')

                # Check if "Approved to Start" is set to True
                if item.item_name == 'Approved to Start' and item.status == 'Pass':
                    vehicle_approved = True

                db.session.add(item)

        # Update checklist-level attributes
        checklist = db.session.get(InspectionChecklist, checklist_id)
        checklist.approved_to_start = vehicle_approved
        checklist.scrutineer_name = request.form.get('scrutineer_name')
        checklist.scrutineer_licence_number = request.form.get('scrutineer_licence_number')

        # Convert date string to Python date object
        date_value = request.form.get('date')
        if date_value:
            checklist.date = datetime.strptime(date_value, '%Y-%m-%d').date()  # Convert to date object

        # Convert time string to Python time object
        time_value = request.form.get('time')
        if time_value:
            checklist.time = datetime.strptime(time_value, '%H:%M:%S').time()  # Convert to time object

        # Commit changes to the database
        db.session.commit()
        flash("Checklist updated successfully!", "success")
        return redirect(url_for('lookup_entry2', checklist_id=checklist_id))

    except Exception as e:
        db.session.rollback()
        print(f"An error occurred: {e}")
        flash("An error occurred while updating the checklist. Please try again.", "error")
        return redirect(url_for('view_checklist2', checklist_id=checklist_id, user=current_user, role=user_role))
                            
# Route: Vehicle Weights
@app.route('/vehicle_weights')
@login_required
def vehicle_weights():
    # Fetch vehicle weights from the database
    vehicles = db.session.query(
        Entry.vehicle_number,
        Entry.driver_name,
        Entry.class_type,
        InspectionItem.value.label('vehicle_weight')
    ).join(InspectionChecklist, Entry.id == InspectionChecklist.entry_id) \
     .join(InspectionItem, InspectionChecklist.id == InspectionItem.checklist_id) \
     .filter(InspectionItem.item_name == "Vehicle Weight") \
     .order_by(
    func.cast(
        func.substr(
            Entry.vehicle_number,
            1,
            func.instr(Entry.vehicle_number + 'A', 'A') - 1
        ),
        Integer
    )
).all() 
## debug
    print("Vehicles Data:", vehicles)
    # Render the template and pass the vehicle data
    return render_template('vehicle_weights.html', vehicles=vehicles)

# Route: Outstanding Items
@app.route('/outstanding_items')
def outstanding_items():
    # Get the sorting preference from the query parameter (default is 'vehicle_number')
    order_by = request.args.get('order_by', 'vehicle_number')

    # Determine the sorting column
    if order_by == 'garage_number':
        order_column = func.cast(
            func.substr(
                Entry.garage_number,
                1,
                func.instr(Entry.garage_number + 'A', 'A') - 1
            ),
            Integer
        )
    else:
        order_column = func.cast(
            func.substr(
                Entry.vehicle_number,
                1,
                func.instr(Entry.vehicle_number + 'A', 'A') - 1
            ),
            Integer
        )
        

    # Fetch vehicles with unresolved inspection items
    items = db.session.query(
        Entry.id.label('entry_id'),
        Entry.vehicle_number,
        Entry.driver_name,
        Entry.class_type,
        Entry.garage_number,
        func.group_concat(InspectionItem.item_name).label('failed_items')
    ).join(InspectionChecklist, Entry.id == InspectionChecklist.entry_id) \
     .join(InspectionItem, InspectionChecklist.id == InspectionItem.checklist_id) \
     .filter(InspectionItem.status.in_(["Pending", "Failed"])) \
     .filter(~InspectionItem.item_name.in_([
         "Vehicle Weight", "Scrutineer Name", "Scrutineer Licence Number", "Date", "Time"
     ])) \
     .group_by(Entry.id) \
     .order_by(order_column).all()

    # Render the template and pass the data
    return render_template('outstanding_items.html', items=items, order_by=order_by)

# Route: Garage Numbers
@app.route('/garage_numbers')
@login_required
def garage_numbers():
    # Get the sorting preference from the query parameter (default is 'vehicle_number')
    order_by = request.args.get('order_by', 'vehicle_number')

    # Determine the sorting column
    if order_by == 'garage_number':
        order_column = func.cast(
            func.substr(
                Entry.garage_number,
                1,
                func.instr(Entry.garage_number + 'A', 'A') - 1
            ),
            Integer
        )
    else:
        order_column = func.cast(
            func.substr(
                Entry.vehicle_number,
                1,
                func.instr(Entry.vehicle_number + 'A', 'A') - 1
            ),
            Integer
        )

    # Fetch vehicle details and garage numbers from the database
    vehicles = db.session.query(
        Entry.vehicle_number,
        Entry.driver_name,
        Entry.class_type,
        Entry.garage_number
    ).order_by(order_column).all()

    # Render the template and pass the vehicle data
    return render_template('garage_numbers.html', vehicles=vehicles, order_by=order_by)

# Update Checklist
@app.route('/update_checklist', methods=['POST'])
@login_required
def update_checklist():
    print(request.form)  # Debug submitted form data
    try:
        checklist_id = request.form.get('checklist_id')
        checklist_items = InspectionItem.query.filter_by(checklist_id=checklist_id).all()

        vehicle_approved = False  # Initialize approval status

        # Use no_autoflush from the session
        with db.session.no_autoflush:
            for item in checklist_items:
                # Handle special items separately
                if item.item_name in ["Vehicle Weight", "Time", "Date", "Scrutineer Name", "Scrutineer Licence Number"]:
                    if item.item_name == "Vehicle Weight":
                        vehicle_weight = request.form.get(f'vehicle_weight_{item.id}')
                        if vehicle_weight:
                            item.value = vehicle_weight
                    elif item.item_name == "Time":
                        time_value = request.form.get('time')
                        if time_value:
                            item.value = time_value
                    elif item.item_name == "Date":
                        date_value = request.form.get('date')
                        if date_value:
                            item.value = date_value
                    continue  # Skip the rest of the loop for these items

                # Update the status from the form data
                status = request.form.get(f'status_{item.id}')
                if status:
                    item.status = status

                # Conditionally update extra fields based on item requirements
                if item.brand_required:
                    item.brand = request.form.get(f'brand_{item.id}')
                if item.standard_required:
                    item.standard = request.form.get(f'standard_{item.id}')
                if item.expiry_date_required:
                    expiry_date_value = request.form.get(f'expiry_date_{item.id}')
                    if expiry_date_value:
                        # Convert the string to a Python date object
                        item.expiry_date = datetime.strptime(expiry_date_value, '%Y-%m-%d').date()
                    else:
                        item.expiry_date = None
                if item.rops_required:
                    item.rops = request.form.get(f'rops_{item.id}')

                # Check if "Approved to Start" is set to True
                if item.item_name == 'Approved to Start' and item.status == 'Pass':
                    vehicle_approved = True

                db.session.add(item)

        # Update checklist-level attributes
        checklist = db.session.get(InspectionChecklist, checklist_id)
        checklist.approved_to_start = vehicle_approved
        checklist.scrutineer_name = request.form.get('scrutineer_name')
        checklist.scrutineer_licence_number = request.form.get('scrutineer_licence_number')

        # Convert date string to Python date object
        date_value = request.form.get('date')
        if date_value:
            checklist.date = datetime.strptime(date_value, '%Y-%m-%d').date()  # Convert to date object

        # Convert time string to Python time object
        time_value = request.form.get('time')
        if time_value:
            checklist.time = datetime.strptime(time_value, '%H:%M:%S').time()  # Convert to time object

        # Commit changes to the database
        db.session.commit()
        flash("Checklist updated successfully!", "success")
        return redirect(url_for('lookup_entry'))

    except Exception as e:
        db.session.rollback()
        print(f"An error occurred: {e}")
        flash("An error occurred while updating the checklist. Please try again.", "error")
        return redirect(url_for('view_checklist', checklist_id=checklist_id))
    
# Route: Denied Start
@app.route('/denied_start')
@login_required
def denied_start():
    # Get the sorting preference from the query parameter (default is 'vehicle_number')
    order_by = request.args.get('order_by', 'vehicle_number')

    # Determine the sorting column
    if order_by == 'garage_number':
        order_column = func.cast(
            func.substr(
                Entry.garage_number,
                1,
                func.instr(Entry.garage_number + 'A', 'A') - 1
            ),
            Integer
        )
    else:
        order_column = func.cast(
            func.substr(
                Entry.vehicle_number,
                1,
                func.instr(Entry.vehicle_number + 'A', 'A') - 1
            ),
            Integer
        )

    # Fetch vehicles where "Approved to Start" is "Fail"
    items = db.session.query(
        Entry.id.label('entry_id'),
        Entry.vehicle_number,
        Entry.driver_name,
        Entry.class_type,
        Entry.garage_number
    ).join(InspectionChecklist, Entry.id == InspectionChecklist.entry_id) \
     .join(InspectionItem, InspectionChecklist.id == InspectionItem.checklist_id) \
     .filter(InspectionItem.item_name == "Approved to Start") \
     .filter(InspectionItem.status == "Fail") \
     .order_by(order_column).all()

    # Render the template and pass the data
    return render_template('denied_start.html', items=items, order_by=order_by)

# Route: Not Approved to start
@app.route('/not_approved')
@login_required
def not_approved():
    # Get the sorting preference from the query parameter (default is 'vehicle_number')
    order_by = request.args.get('order_by', 'vehicle_number')

    # Determine the sorting column
    if order_by == 'garage_number':
        order_column = func.cast(
            func.substr(
                Entry.garage_number,
                1,
                func.instr(Entry.garage_number + 'A', 'A') - 1
            ),
            Integer
        )
    else:
        order_column = func.cast(
            func.substr(
                Entry.vehicle_number,
                1,
                func.instr(Entry.vehicle_number + 'A', 'A') - 1
            ),
            Integer
        )

    # Fetch vehicles where "Approved to Start" is "Pending" or "N/A"
    items = db.session.query(
        Entry.id.label('entry_id'),
        Entry.vehicle_number,
        Entry.driver_name,
        Entry.class_type,
        Entry.garage_number
    ).join(InspectionChecklist, Entry.id == InspectionChecklist.entry_id) \
     .join(InspectionItem, InspectionChecklist.id == InspectionItem.checklist_id) \
     .filter(InspectionItem.item_name == "Approved to Start") \
     .filter(InspectionItem.status.in_(["Pending", "NA"])) \
     .order_by(order_column).all()
    # Render the template and pass the data
    return render_template('not_approved.html', items=items, order_by=order_by)

# Route: Denied Start Counter
@app.route('/denied_start_count')
@login_required
def denied_start_count():
    # Count vehicles where "Approved to Start" is "Fail"

    count = db.session.query(Entry).join(InspectionChecklist, Entry.id == InspectionChecklist.entry_id) \
        .join(InspectionItem, InspectionChecklist.id == InspectionItem.checklist_id) \
        .filter(InspectionItem.item_name == "Approved to Start") \
        .filter(InspectionItem.status == "Fail").count()

    # Return the count as JSON
    return jsonify({'denied_start_count': count})

# Route: Not Presented
@app.route('/not_presented')
@login_required
def not_presented():
    # Get the sorting preference from the query parameter (default is 'vehicle_number')
    order_by = request.args.get('order_by', 'vehicle_number')

    # Determine the sorting column
    if order_by == 'garage_number':
        order_column = func.cast(
            func.substr(
                Entry.garage_number,
                1,
                func.instr(Entry.garage_number + 'A', 'A') - 1
            ),
            Integer
        )
    else:
        order_column = func.cast(
            func.substr(
                Entry.vehicle_number,
                1,
                func.instr(Entry.vehicle_number + 'A', 'A') - 1
            ),
            Integer
        )

    # Fetch vehicles without an associated checklist
    vehicles = db.session.query(
        Entry.id,
        Entry.vehicle_number,
        Entry.driver_name,
        Entry.class_type,
        Entry.garage_number
    ).outerjoin(InspectionChecklist, Entry.id == InspectionChecklist.entry_id) \
     .filter(InspectionChecklist.id == None) \
     .order_by(order_column).all()

    # Render the template and pass the vehicle data
    return render_template('not_presented.html', vehicles=vehicles, order_by=order_by)

# Route: Print Scrutiners
@app.route('/scrutineers')
@admin_required
def scrutineers_list():
    user_role = current_user.role
    scrutineers = Officials.query.filter_by(role="Scrutineer").order_by(Officials.name.asc()).all()
    return render_template('scrutineers.html', scrutineers=scrutineers, user=current_user, role=user_role)

# Route: Add Officals
@app.route('/add_official', methods=['GET', 'POST'])
@admin_required
def add_official():
    user_role = current_user.role
    if request.method == 'POST':
        # Get data from the form
        name = request.form.get('name')
        role = request.form.get('role')
        licence_number = request.form.get('licence_number')
        contact_info = request.form.get('contact_info')

        # Validate required fields
        if not name or not role or not licence_number:
            roles = Roles.query.all()
            return render_template('add_official.html', error="Please fill in all required fields.", roles=roles)

        # Create a new Official object
        new_official = Officials(
            name=name,
            role=role,
            licence_number=licence_number,
            contact_info=contact_info,
        )

        try:
            db.session.add(new_official)
            db.session.commit()
            return redirect('/add_official')
        except Exception as e:
            db.session.rollback()
            print(f"Error: {e}")
            roles = Roles.query.all()
            return render_template('add_official.html', error="Failed to add official. Please try again.", roles=roles, user=current_user, role=user_role)

    # Handle GET request
    roles = Roles.query.all()
    return render_template('add_official.html', roles=roles)

@app.route('/manage_entries', methods=['GET', 'POST'])
@admin_required
def manage_entries():
    # List of valid classes for the dropdown.
    valid_classes = ["Tuner", "Clubsprint", "Open", "Pro Open", "Pro Am", "Pro", "Flying 500", "Demo"]
    
    if request.method == 'POST':
        action = request.form.get('action')
        entry_id = request.form.get('entry_id')
        entry = db.session.get(Entry, entry_id)
        if not entry:
            flash("Entry not found.", "danger")
            return redirect(url_for('manage_entries'))
        
        if action == 'save':
            # Update all editable fields.
            entry.vehicle_number = request.form.get('vehicle_number')
            entry.driver_name = request.form.get('driver_name')
            new_class = request.form.get('class_type')
            if new_class:
                entry.class_type = new_class.replace(' ', '_').lower()
            entry.garage_number = request.form.get('garage_number')
            
            try:
                db.session.commit()
                flash("Entry updated successfully!", "success")
            except Exception as e:
                db.session.rollback()
                flash("Failed to update the entry.", "danger")
        
        elif action == 'delete':
            try:
                # If an associated checklist exists, delete it and its related items.
                checklist = InspectionChecklist.query.filter_by(entry_id=entry.id).first()
                if checklist:
                    InspectionItem.query.filter_by(checklist_id=checklist.id).delete()
                    db.session.delete(checklist)
                db.session.delete(entry)
                db.session.commit()
                flash("Entry (and its associated checklist, if any) deleted successfully!", "success")
            except Exception as e:
                db.session.rollback()
                flash("Failed to delete the entry.", "danger")
        
        return redirect(url_for('manage_entries'))
    
    # For GET requests, fetch and order all entries by the numeric portion of vehicle_number.
    order_num = func.cast(
        func.substr(Entry.vehicle_number, 1, func.instr(Entry.vehicle_number + 'A', 'A') - 1),
        Integer
    )
    entries = Entry.query.order_by(order_num.asc()).all()
    
    return render_template('manage_entries.html', entries=entries, valid_classes=valid_classes)

# Route: Admin View/Delete Checklists
@app.route('/manage_checklists', methods=['GET', 'POST'])
@admin_required
def manage_checklists():
    if request.method == 'POST':
        action = request.form.get('action')
        checklist_id = request.form.get('checklist_id')
        checklist = db.session.get(InspectionChecklist, checklist_id)
        if not checklist:
            flash("Checklist not found.", "danger")
            return redirect(url_for('manage_checklists'))
        
        if action == 'delete':
            try:
                # Delete associated inspection items first, if any.
                InspectionItem.query.filter_by(checklist_id=checklist.id).delete()
                db.session.delete(checklist)
                db.session.commit()
                flash("Checklist deleted successfully!", "success")
            except Exception as e:
                db.session.rollback()
                flash("Failed to delete the checklist.", "danger")
            return redirect(url_for('manage_checklists'))
    
    # For GET requests, we need to fetch all checklists along with related Entry info.
    # We also want to extract the numeric part of the vehicle_number for proper sorting.
    order_num = func.cast(
        func.substr(Entry.vehicle_number, 1, func.instr(Entry.vehicle_number + 'A', 'A') - 1),
        Integer
    )
    # Define conditional aggregation for checking if any item is failed or pending.
    failed_flag = func.max(case((InspectionItem.status == 'Fail', 1), else_=0)).label('has_failed')
    pending_flag = func.max(case((InspectionItem.status == 'Pending', 1), else_=0)).label('has_pending')
    
    # Build the query joining InspectionChecklist to Entry and left joining InspectionItem.
    checklists = db.session.query(
        InspectionChecklist.id.label('checklist_id'),
        Entry.vehicle_number,
        Entry.driver_name,
        InspectionChecklist.approved_to_start,
        failed_flag,
        pending_flag
    ).join(Entry, InspectionChecklist.entry_id == Entry.id) \
     .outerjoin(InspectionItem, InspectionChecklist.id == InspectionItem.checklist_id) \
     .group_by(InspectionChecklist.id, Entry.vehicle_number, Entry.driver_name, InspectionChecklist.approved_to_start) \
     .order_by(order_num.asc()).all()
    
    return render_template('manage_checklists.html', checklists=checklists)

# Route: Admin View/Delete Officials
@app.route('/manage_officials', methods=['GET', 'POST'])
@admin_required
def manage_officials():
    if request.method == 'POST':
        action = request.form.get('action')
        official_id = request.form.get('official_id')
        # Use the new API to retrieve the official record.
        official = db.session.get(Officials, official_id)
        if not official:
            flash("Official not found.", "danger")
            return redirect(url_for('manage_officials'))

        if action == 'save':
            # Update all editable fields.
            official.name = request.form.get('name')
            official.licence_number = request.form.get('licence_number')
            official.contact_info = request.form.get('contact_info')
            new_role = request.form.get('role')
            if new_role:
                official.role = new_role
            try:
                db.session.commit()
                flash("Official updated successfully!", "success")
            except Exception as e:
                db.session.rollback()
                flash("Failed to update the official.", "danger")
        
        elif action == 'delete':
            try:
                db.session.delete(official)
                db.session.commit()
                flash("Official deleted successfully!", "success")
            except Exception as e:
                db.session.rollback()
                flash("Failed to delete the official.", "danger")

        return redirect(url_for('manage_officials'))
    
    # For GET requests, fetch and order all officials by name.
    officials = Officials.query.order_by(Officials.name.asc()).all()

    # Get valid roles for the drop-down.
    # We assume you have a Roles model and want to list them in alphabetical order.
    roles_query = Roles.query.order_by(Roles.role_name.asc()).all()
    roles_list = [role.role_name for role in roles_query]
    # Fallback to a default list if no roles are defined.
    if not roles_list:
        roles_list = ["Admin", "Scrutineer", "User", "Other"]

    return render_template('manage_officials.html', officials=officials, roles_list=roles_list)

# Route: Admin Import CSV to Entries
@app.route('/import_entries', methods=['GET', 'POST'])
@admin_required
def import_entries():
    if request.method == 'POST':
        print("Request Files:", request.files)  # Debug
        csv_file = request.files.get('csv_file')
        
        if not csv_file or csv_file.filename == '':
            flash("No file uploaded", "danger")
            print("No file selected")  # Debug
            return redirect(url_for('import_entries'))
            
        if not csv_file.filename.endswith('.csv'):
            flash("Please upload a CSV file", "danger")
            print("Invalid file type")  # Debug
            return redirect(url_for('import_entries'))
            
        try:
            # Read CSV with UTF-8-SIG to handle BOM
            content = csv_file.stream.read().decode('utf-8-sig')
            print("Raw content (first 500 chars):", content[:500])  # Debug
            
            # Get CSV headers and data
            csv_reader = csv.reader(io.StringIO(content))
            headers = next(csv_reader)  # Get headers
            csv_data = list(csv_reader)  # Get all rows
            
            print("CSV Headers:", headers)  # Debug
            print(f"Rows read: {len(csv_data)}")  # Debug
            
            # Define the database columns we want to map
            db_columns = [
                'vehicle_number',
                'driver_name',
                'vehicle_make',
                'vehicle_model',
                'class_type',
                'team_name',
                'garage_number',
                'log_book_number',
                'licence_number'
            ]
            
            # Convert data to JSON-safe format
            json_safe_data = []
            for row in csv_data:
                json_safe_data.append([str(cell) for cell in row])
            
            return render_template(
                'mapping.html',
                csv_headers=headers,
                db_columns=db_columns,
                csv_data=json_safe_data
            )
            
        except Exception as e:
            flash(f"Error processing file: {str(e)}", "danger")
            print(f"Error: {str(e)}")  # Debug
            return redirect(url_for('import_entries'))
            
    return render_template('import.html')

@app.route('/preview_data', methods=['POST'])
@admin_required
def preview_data():
    try:
        print("Form data received:", request.form)  # Debug
        
        # Get raw CSV data and headers
        raw_csv_data = json.loads(request.form.get('raw_csv_data'))
        raw_csv_headers = json.loads(request.form.get('raw_csv_headers'))
        
        # Get mappings
        mappings = {}
        for key, value in request.form.items():
            if key.startswith('mapping['):
                db_field = key[8:-1]  # Remove 'mapping[' and ']'
                mappings[db_field] = value if value else ''
        
        # Valid classes list - now including "Blank"
        valid_classes = ['Tuner', 'Clubsprint', 'Open', 'Pro Open', 'Pro Am', 
                        'Pro', 'Flying 500', 'Demo', 'Blank']
        
        # Process rows
        processed_rows = []
        for row_data in raw_csv_data:
            # Create a dictionary from the row using headers
            row = dict(zip(raw_csv_headers, row_data))
            
            processed_row = {}
            
            # Map CSV columns to database fields
            for db_col, csv_col in mappings.items():
                if csv_col:  # Only map if a column was selected
                    processed_row[db_col] = row.get(csv_col, '')
                else:
                    processed_row[db_col] = ''

            # Set default vehicle type
            processed_row['vehicle_type'] = 'W'

            # Normalize class type
            class_type = processed_row.get('class_type', '').lower()
            class_mapping = {
                'proam': 'Pro Am',
                'proopen': 'Pro Open',
                'demonstration': 'Demo',
                'flying500': 'Flying 500',
                'drift': 'Blank',  # Map drift to Blank
                '': 'Blank'  # Map empty to Blank
            }
            
            # Get normalized class or title case the existing value
            normalized_class = class_mapping.get(class_type, class_type.title())
            
            # If normalized class isn't in valid_classes or is Blank, set to "Blank" and mark for exclusion
            if normalized_class not in valid_classes or normalized_class == 'Blank':
                processed_row['class_type'] = 'Blank'
                processed_row['should_exclude'] = True  # Mark for exclusion
            else:
                processed_row['class_type'] = normalized_class
                processed_row['should_exclude'] = False

            # Add class suffix to vehicle number if numeric
            if processed_row.get('vehicle_number', '').isdigit():
                suffix_mapping = {
                    'Tuner': 'T',
                    'Clubsprint': 'C',
                    'Open': 'O',
                    'Pro Open': 'PO',
                    'Pro Am': 'PA',
                    'Pro': 'P',
                    'Flying 500': 'F',
                    'Demo': 'D',
                    'Blank': ''  # No suffix for Blank class
                }
                suffix = suffix_mapping.get(processed_row['class_type'], '')
                if suffix:
                    processed_row['vehicle_number'] = f"{processed_row['vehicle_number']}{suffix}"

            processed_rows.append(processed_row)

        print(f"Processed {len(processed_rows)} rows")  # Debug

        return render_template('preview_data.html',
                             rows=processed_rows,
                             valid_classes=valid_classes)

    except Exception as e:
        print(f"Error in preview_data: {str(e)}")  # Debug
        print(f"Request form data: {request.form}")  # Debug
        flash(f"Error processing data: {str(e)}", "danger")
        return redirect(url_for('import_entries'))

@app.route('/import_data', methods=['POST'])
@admin_required
def import_data():
    try:
        print("Starting data import...")  # Debug
        
        # Get all form data
        form_data = request.form.to_dict(flat=False)  # Get as multidict to handle arrays
        
        # Get the number of entries based on vehicle numbers length
        num_entries = len(form_data.get('vehicle_number[]', []))
        print(f"Number of entries to process: {num_entries}")  # Debug
        
        # Track duplicates for reporting
        duplicates = []
        imported = []
        
        # Get existing vehicle numbers
        existing_numbers = {
            number[0] for number in 
            db.session.query(Entry.vehicle_number).all()
        }
        
        # Process each entry
        entries = []
        for i in range(num_entries):
            # Skip if this row is marked for exclusion
            if form_data.get('exclude[]', []):
                if len(form_data['exclude[]']) > i and form_data['exclude[]'][i] == 'true':
                    print(f"Skipping excluded row {i}")  # Debug
                    continue
            
            vehicle_number = form_data['vehicle_number[]'][i] if i < len(form_data['vehicle_number[]']) else ''
            
            # Skip entries with no vehicle number or marked as NULL
            if not vehicle_number or vehicle_number == 'NULL':
                print(f"Skipping entry with no vehicle number")  # Debug
                continue
            
            # Check for duplicates both in database and current import
            if vehicle_number in existing_numbers:
                print(f"Duplicate vehicle number found in database: {vehicle_number}")  # Debug
                duplicates.append(vehicle_number)
                continue

            # Get values with safe fallbacks for all fields
            log_book = form_data.get('log_book_number[]', [''])[i] if i < len(form_data.get('log_book_number[]', [])) else ''
            licence = form_data.get('licence_number[]', [''])[i] if i < len(form_data.get('licence_number[]', [])) else ''
                
            entry = Entry(
                vehicle_number=vehicle_number,
                driver_name=form_data['driver_name[]'][i] if i < len(form_data['driver_name[]']) else '',
                vehicle_make=form_data['vehicle_make[]'][i] if i < len(form_data['vehicle_make[]']) else '',
                vehicle_model=form_data['vehicle_model[]'][i] if i < len(form_data['vehicle_model[]']) else '',
                class_type=form_data['class_type[]'][i] if i < len(form_data['class_type[]']) else '',
                team_name=form_data['team_name[]'][i] if i < len(form_data['team_name[]']) else '',
                garage_number=form_data['garage_number[]'][i] if i < len(form_data['garage_number[]']) else '',
                log_book_number=log_book,
                licence_number=licence,
                vehicle_type='W'  # Default value
            )
            entries.append(entry)
            imported.append(vehicle_number)
            # Add to existing numbers to catch duplicates within current import
            existing_numbers.add(vehicle_number)
        
        print(f"Processed {len(entries)} valid entries")  # Debug
        
        try:
            # Add all entries to the session
            for entry in entries:
                db.session.add(entry)
            
            # Commit the transaction
            db.session.commit()
            
            # Create appropriate flash messages
            if imported:
                flash(f"Successfully imported {len(imported)} entries", "success")
            if duplicates:
                flash(f"Skipped {len(duplicates)} duplicate entries: {', '.join(duplicates)}", "warning")
            if not imported and duplicates:
                flash("No new entries were imported - all were duplicates", "warning")
            
        except Exception as e:
            db.session.rollback()
            print(f"Database error: {str(e)}")  # Debug
            flash(f"Error importing data: {str(e)}", "danger")
            
        return redirect(url_for('manage_entries'))
        
    except Exception as e:
        print(f"Error in import_data: {str(e)}")  # Debug
        print(f"Form data: {request.form}")  # Debug
        flash(f"Error importing data: {str(e)}", "danger")
        return redirect(url_for('import_entries'))

# Route: Admin Import CSV to Officials
@app.route('/import_officials')
@admin_required
def import_officials():
    raise NotImplementedError("This route is not implemented yet.")

# Route: Delete Entries and Checklists
@app.route('/purge_database', methods=['GET', 'POST'])
@admin_required
def purge_database():
    if request.method == 'POST':
        try:
            # Delete all inspection items first.
            num_items = InspectionItem.query.delete()
            # Delete all checklists.
            num_checklists = InspectionChecklist.query.delete()
            # Finally, delete all entries.
            num_entries = Entry.query.delete()
            db.session.commit()
            flash(
                f"Purged database: Deleted {num_entries} entries, {num_checklists} checklists, and {num_items} inspection items.",
                "success"
            )
        except Exception as e:
            db.session.rollback()
            flash("Error purging database: " + str(e), "danger")
        return redirect(url_for('wtac_dashboard'))
    # For a GET request, render a confirmation template.
    return render_template('purge_confirmation.html')

# Endpoint: Get total entries with vehicle_type 'W'
@app.route('/total_entries', methods=['GET'])
@login_required
def total_entries():
    total = Entry.query.filter_by(vehicle_type='W').count()
    return jsonify({'total_entries': total})

# Endpoint: Get total entries per class
@app.route('/class_entries', methods=['GET'])
@login_required
def class_entries():
    entries = db.session.query(Entry.class_type, db.func.count(Entry.class_type)) \
                        .filter_by(vehicle_type='W') \
                        .group_by(Entry.class_type) \
                        .all()
    return jsonify({'class_entries': [{row[0]: row[1]} for row in entries]})

# Endpoint: Get total entries without inspection reports
@app.route('/missing_inspections', methods=['GET'])
@login_required
def missing_inspections():
    # Query entries without matching checklists
    entries = Entry.query.filter(
        ~Entry.id.in_(db.session.query(InspectionChecklist.entry_id))
    ).all()
    return jsonify({'missing_inspections': [entry.id for entry in entries]})

# Endpoint: Get total entries not approved to start
@app.route('/not_approved_to_start', methods=['GET'])
@login_required
def not_approved_to_start():
    try:
        # Query entries where approved_to_start is FALSE
        not_approved_entries = db.session.query(Entry.id).join(InspectionChecklist).filter(
            InspectionChecklist.approved_to_start == False
        ).distinct().all()

        # Extract the IDs into a list
        not_approved_entry_ids = [entry[0] for entry in not_approved_entries]

        # Return the count and IDs of entries without approval to start
        return jsonify({
            'not_approved_to_start_count': len(not_approved_entry_ids),
            'not_approved_entries': not_approved_entry_ids
        })

    except Exception as e:
        # Handle any errors
        return jsonify({'error': str(e)})

# Endpoint: Get total entries with failed items
@app.route('/failed_items', methods=['GET'])
@login_required
def failed_items():
    try:
        # Query entries that have at least one failed item
        failed_entries = db.session.query(Entry.id).join(InspectionChecklist).join(InspectionItem).filter(
            InspectionItem.status == 'Fail'
        ).distinct().all()

        # Extract the IDs into a list
        failed_entry_ids = [entry[0] for entry in failed_entries]

        # Return the count and IDs of entries with failed items
        return jsonify({
            'failed_items_count': len(failed_entry_ids),
            'failed_entries': failed_entry_ids
        })

    except Exception as e:
        # Handle any errors
        return jsonify({'error': str(e)})

# Formula Ford Routes
@app.route('/formula_ford/round1')
@login_required
def formula_ford_round1():
    return render_template('formula_ford/round1.html', user=current_user, role=current_user.role)

@app.route('/formula_ford/round2')
@login_required
def formula_ford_round2():
    return render_template('formula_ford/round2.html', user=current_user, role=current_user.role)

@app.route('/formula_ford/round3')
@login_required
def formula_ford_round3():
    return render_template('formula_ford/round3.html', user=current_user, role=current_user.role)

@app.route('/formula_ford/round4')
@login_required
def formula_ford_round4():
    return render_template('formula_ford/round4.html', user=current_user, role=current_user.role)

@app.route('/formula_ford/round5')
@login_required
def formula_ford_round5():
    return render_template('formula_ford/round5.html', user=current_user, role=current_user.role)

@app.route('/formula_ford/round6')
@login_required
def formula_ford_round6():
    return render_template('formula_ford/round6.html', user=current_user, role=current_user.role)

@app.route('/formula_ford/events')
@login_required
def manage_formula_ford_events():
    events = FormulaFordEvent.query.order_by(FormulaFordEvent.round_number).all()
    return render_template('formula_ford/manage_events.html', events=events)

@app.route('/formula_ford/events/add', methods=['POST'])
@login_required
def add_formula_ford_event():
    try:
        round_number = request.form.get('round_number', type=int)
        location = request.form.get('location')
        event_date = request.form.get('event_date')

        if not all([round_number, location, event_date]):
            flash('All fields are required', 'error')
            return redirect(url_for('manage_formula_ford_events'))

        # Check if round number already exists
        existing_event = FormulaFordEvent.query.filter_by(round_number=round_number).first()
        if existing_event:
            flash(f'Round {round_number} already exists', 'error')
            return redirect(url_for('manage_formula_ford_events'))

        new_event = FormulaFordEvent(
            round_number=round_number,
            location=location,
            event_date=datetime.strptime(event_date, '%Y-%m-%d').date()
        )
        db.session.add(new_event)
        db.session.commit()
        flash(f'Event Round {round_number} added successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error adding event: {str(e)}', 'error')
    
    return redirect(url_for('manage_formula_ford_events'))

@app.route('/formula_ford/events/<int:event_id>/competitors')
@login_required
def event_competitors(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    entries = FormulaFordEventEntry.query.filter_by(event_id=event_id).all()
    competitors = [entry.competitor for entry in entries]
    return render_template('formula_ford/event_competitors.html', 
                           event=event, 
                           competitors=competitors,
                           FormulaFordCompetitor=FormulaFordCompetitor)

@app.route('/formula_ford/events/<int:event_id>/technical_checks')
@login_required
def event_technical_checks(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    checks = FormulaFordTechnicalCheck.query.filter_by(event_id=event_id).all()
    return render_template('formula_ford/technical_checks.html', event=event, checks=checks)

@app.route('/formula_ford/events/<int:event_id>/tyre_checks')
@login_required
def event_tyre_checks(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    checks = FormulaFordTyreCheck.query.filter_by(event_id=event_id).all()
    return render_template('formula_ford/tyre_checks.html', event=event, checks=checks)

@app.route('/formula_ford/events/<int:event_id>/timetable')
@login_required
def event_timetable(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    sessions = TimetableSession.query.filter_by(event_id=event_id).order_by(TimetableSession.start_time).all()
    return render_template('formula_ford/timetable.html', event=event, sessions=sessions)

@app.route('/formula_ford/events/<int:event_id>/competitors/add', methods=['POST'])
@login_required
def add_event_competitor(event_id):
    competitor_id = request.form.get('competitor_id')
    entry_status = request.form.get('entry_status')

    if not all([competitor_id, entry_status]):
        flash('All fields are required', 'error')
        return redirect(url_for('event_competitors', event_id=event_id))

    try:
        entry = FormulaFordEventEntry(
            event_id=event_id,
            competitor_id=competitor_id,
            entry_status=entry_status
        )
        db.session.add(entry)
        db.session.commit()
        flash('Competitor added to event successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error adding competitor to event: {str(e)}', 'error')

    return redirect(url_for('event_competitors', event_id=event_id))

@app.route('/formula_ford/events/<int:event_id>/competitors/<int:competitor_id>/technical_check')
@login_required
def competitor_technical_check(event_id, competitor_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    competitor = FormulaFordCompetitor.query.get_or_404(competitor_id)
    check = FormulaFordTechnicalCheck.query.filter_by(
        event_id=event_id,
        competitor_id=competitor_id
    ).first()
    return render_template('formula_ford/competitor_technical_check.html',
                         event=event,
                         competitor=competitor,
                         check=check)

@app.route('/formula_ford/events/<int:event_id>/competitors/<int:competitor_id>/tyre_check')
@login_required
def competitor_tyre_check(event_id, competitor_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    competitor = FormulaFordCompetitor.query.get_or_404(competitor_id)
    check = FormulaFordTyreCheck.query.filter_by(
        event_id=event_id,
        competitor_id=competitor_id
    ).first()
    return render_template('formula_ford/competitor_tyre_check.html',
                         event=event,
                         competitor=competitor,
                         check=check)

@app.route('/formula_ford/events/<int:event_id>/entries/<int:entry_id>/edit')
@login_required
def edit_event_entry(event_id, entry_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    entry = FormulaFordEventEntry.query.get_or_404(entry_id)
    return render_template('formula_ford/edit_event_entry.html',
                         event=event,
                         entry=entry)

@app.route('/formula_ford/events/<int:event_id>/competitors/<int:competitor_id>/technical_check/submit', methods=['POST'])
@login_required
def submit_technical_check(event_id, competitor_id):
    weight = request.form.get('weight')
    height_status = request.form.get('height_status')
    fuel_status = request.form.get('fuel_status')
    safety_equipment_status = request.form.get('safety_equipment_status')
    notes = request.form.get('notes')
    inspector_name = request.form.get('inspector_name')
    check_date = request.form.get('check_date')

    if not all([weight, height_status, fuel_status, safety_equipment_status, inspector_name, check_date]):
        flash('All required fields must be filled', 'error')
        return redirect(url_for('competitor_technical_check', event_id=event_id, competitor_id=competitor_id))

    try:
        check = FormulaFordTechnicalCheck.query.filter_by(
            event_id=event_id,
            competitor_id=competitor_id
        ).first()

        if check:
            check.weight = float(weight)
            check.height_status = height_status
            check.fuel_status = fuel_status
            check.safety_equipment_status = safety_equipment_status
            check.notes = notes
            check.inspector_name = inspector_name
            check.check_date = datetime.strptime(check_date, '%Y-%m-%d').date()
        else:
            check = FormulaFordTechnicalCheck(
                event_id=event_id,
                competitor_id=competitor_id,
                weight=float(weight),
                height_status=height_status,
                fuel_status=fuel_status,
                safety_equipment_status=safety_equipment_status,
                notes=notes,
                inspector_name=inspector_name,
                check_date=datetime.strptime(check_date, '%Y-%m-%d').date()
            )
            db.session.add(check)

        db.session.commit()
        flash('Technical check submitted successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error submitting technical check: {str(e)}', 'error')

    return redirect(url_for('competitor_technical_check', event_id=event_id, competitor_id=competitor_id))

@app.route('/formula_ford/events/<int:event_id>/competitors/<int:competitor_id>/tyre_check/submit', methods=['POST'])
@login_required
def submit_tyre_check(event_id, competitor_id):
    practice_tyre_brand = request.form.get('practice_tyre_brand')
    practice_tyre_compound = request.form.get('practice_tyre_compound')
    practice_tyre_serial_numbers = request.form.get('practice_tyre_serial_numbers')
    race_tyre_brand = request.form.get('race_tyre_brand')
    race_tyre_compound = request.form.get('race_tyre_compound')
    race_tyre_serial_numbers = request.form.get('race_tyre_serial_numbers')
    inspector_name = request.form.get('inspector_name')
    check_date = request.form.get('check_date')
    notes = request.form.get('notes')

    if not all([practice_tyre_brand, practice_tyre_compound, practice_tyre_serial_numbers,
                race_tyre_brand, race_tyre_compound, race_tyre_serial_numbers,
                inspector_name, check_date]):
        flash('All required fields must be filled', 'error')
        return redirect(url_for('competitor_tyre_check', event_id=event_id, competitor_id=competitor_id))

    try:
        check = FormulaFordTyreCheck.query.filter_by(
            event_id=event_id,
            competitor_id=competitor_id
        ).first()

        if check:
            check.practice_tyre_brand = practice_tyre_brand
            check.practice_tyre_compound = practice_tyre_compound
            check.practice_tyre_serial_numbers = practice_tyre_serial_numbers
            check.race_tyre_brand = race_tyre_brand
            check.race_tyre_compound = race_tyre_compound
            check.race_tyre_serial_numbers = race_tyre_serial_numbers
            check.inspector_name = inspector_name
            check.check_date = datetime.strptime(check_date, '%Y-%m-%d').date()
            check.notes = notes
        else:
            check = FormulaFordTyreCheck(
                event_id=event_id,
                competitor_id=competitor_id,
                practice_tyre_brand=practice_tyre_brand,
                practice_tyre_compound=practice_tyre_compound,
                practice_tyre_serial_numbers=practice_tyre_serial_numbers,
                race_tyre_brand=race_tyre_brand,
                race_tyre_compound=race_tyre_compound,
                race_tyre_serial_numbers=race_tyre_serial_numbers,
                inspector_name=inspector_name,
                check_date=datetime.strptime(check_date, '%Y-%m-%d').date(),
                notes=notes
            )
            db.session.add(check)

        db.session.commit()
        flash('Tyre check submitted successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error submitting tyre check: {str(e)}', 'error')

    return redirect(url_for('competitor_tyre_check', event_id=event_id, competitor_id=competitor_id))

@app.route('/formula_ford/events/<int:event_id>/entries/<int:entry_id>/update', methods=['POST'])
@login_required
def update_event_entry(event_id, entry_id):
    entry_status = request.form.get('entry_status')
    notes = request.form.get('notes')

    if not entry_status:
        flash('Entry status is required', 'error')
        return redirect(url_for('edit_event_entry', event_id=event_id, entry_id=entry_id))

    try:
        entry = FormulaFordEventEntry.query.get_or_404(entry_id)
        entry.entry_status = entry_status
        entry.notes = notes
        db.session.commit()
        flash('Entry updated successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating entry: {str(e)}', 'error')

    return redirect(url_for('event_competitors', event_id=event_id))

@app.route('/formula_ford/events/<int:event_id>/entries/<int:entry_id>/delete', methods=['POST'])
@login_required
def delete_event_entry(event_id, entry_id):
    try:
        entry = FormulaFordEventEntry.query.get_or_404(entry_id)
        db.session.delete(entry)
        db.session.commit()
        flash('Entry deleted successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting entry: {str(e)}', 'error')

    return redirect(url_for('event_competitors', event_id=event_id))

@app.route('/formula_ford/events/<int:event_id>/timetable/add', methods=['POST'])
@login_required
def add_timetable_session(event_id):
    session_name = request.form.get('session_name')
    session_type = request.form.get('session_type')
    start_time = request.form.get('start_time')
    duration = request.form.get('duration')

    if not all([session_name, session_type, start_time, duration]):
        flash('All fields are required', 'error')
        return redirect(url_for('event_timetable', event_id=event_id))

    try:
        session = TimetableSession(
            event_id=event_id,
            session_name=session_name,
            session_type=session_type,
            start_time=datetime.strptime(start_time, '%H:%M').time(),
            duration=int(duration)
        )
        db.session.add(session)
        db.session.commit()
        flash('Session added successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error adding session: {str(e)}', 'error')

    return redirect(url_for('event_timetable', event_id=event_id))

@app.route('/formula_ford/events/<int:event_id>/timetable/<int:session_id>/edit')
@login_required
def edit_timetable_session(event_id, session_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    session = TimetableSession.query.get_or_404(session_id)
    return render_template('formula_ford/edit_timetable_session.html',
                         event=event,
                         session=session)

@app.route('/formula_ford/events/<int:event_id>/timetable/<int:session_id>/update', methods=['POST'])
@login_required
def update_timetable_session(event_id, session_id):
    session_name = request.form.get('session_name')
    session_type = request.form.get('session_type')
    start_time = request.form.get('start_time')
    duration = request.form.get('duration')

    if not all([session_name, session_type, start_time, duration]):
        flash('All fields are required', 'error')
        return redirect(url_for('edit_timetable_session', event_id=event_id, session_id=session_id))

    try:
        session = TimetableSession.query.get_or_404(session_id)
        session.session_name = session_name
        session.session_type = session_type
        session.start_time = datetime.strptime(start_time, '%H:%M').time()
        session.duration = int(duration)
        db.session.commit()
        flash('Session updated successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating session: {str(e)}', 'error')

    return redirect(url_for('event_timetable', event_id=event_id))

@app.route('/formula_ford/events/<int:event_id>/timetable/<int:session_id>/delete', methods=['POST'])
@login_required
def delete_timetable_session(event_id, session_id):
    try:
        session = TimetableSession.query.get_or_404(session_id)
        db.session.delete(session)
        db.session.commit()
        flash('Session deleted successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting session: {str(e)}', 'error')

    return redirect(url_for('event_timetable', event_id=event_id))

@app.route('/formula_ford/competitors')
@login_required
def manage_formula_ford_competitors():
    # Get sorting parameter from query string, default to car_number
    sort_by = request.args.get('sort_by', 'car_number')
    
    # Define the sorting criteria
    if sort_by == 'name':
        order_by = [FormulaFordCompetitor.last_name, FormulaFordCompetitor.first_name]
    elif sort_by == 'team':
        order_by = [FormulaFordCompetitor.team_association]
    elif sort_by == 'vehicle':
        order_by = [FormulaFordCompetitor.vehicle_make, FormulaFordCompetitor.vehicle_type]
    else:  # default to car_number
        order_by = [FormulaFordCompetitor.car_number]
    
    # Get all competitors with the specified sorting
    competitors = FormulaFordCompetitor.query.order_by(*order_by).all()
    
    return render_template('formula_ford/manage_competitors.html', 
                         competitors=competitors,
                         sort_by=sort_by)

@app.route('/formula_ford/competitors/add', methods=['POST'])
@login_required
def add_formula_ford_competitor():
    try:
        # Debug: Print all form data
        print("=== FORM DATA RECEIVED ===")
        for key, value in request.form.items():
            print(f"{key}: {value}")
        
        # Get form data
        first_name = request.form.get('first_name')
        last_name = request.form.get('last_name')
        team_association = request.form.get('team_association')
        vehicle_make = request.form.get('vehicle_make')
        vehicle_type = request.form.get('vehicle_type')
        car_number = request.form.get('car_number')

        print(f"Parsed values: first_name={first_name}, last_name={last_name}, car_number={car_number}")

        # Validate required fields
        if not all([first_name, last_name, vehicle_make, vehicle_type, car_number]):
            print("Validation failed: Missing required fields")
            flash('Please fill in all required fields', 'error')
            return redirect(url_for('manage_formula_ford_competitors'))

        try:
            car_number = int(car_number)
        except ValueError:
            print(f"Validation failed: Car number '{car_number}' is not a valid integer")
            flash('Car number must be a valid number', 'error')
            return redirect(url_for('manage_formula_ford_competitors'))
            
        # Check if car number already exists
        existing = FormulaFordCompetitor.query.filter_by(car_number=car_number).first()
        if existing:
            print(f"Validation failed: Car number {car_number} already exists")
            flash(f'Car number {car_number} is already in use', 'error')
            return redirect(url_for('manage_formula_ford_competitors'))

        # Create new competitor
        competitor = FormulaFordCompetitor(
            first_name=first_name,
            last_name=last_name,
            team_association=team_association,
            vehicle_make=vehicle_make,
            vehicle_type=vehicle_type,
            car_number=car_number
        )

        db.session.add(competitor)
        db.session.commit()
        print(f"Success: Added competitor ID {competitor.id}")
        flash('Competitor added successfully', 'success')

    except Exception as e:
        db.session.rollback()
        print(f"Error adding competitor: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Error adding competitor: {str(e)}', 'error')

    return redirect(url_for('manage_formula_ford_competitors'))

@app.route('/formula_ford/competitors/<int:competitor_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_formula_ford_competitor(competitor_id):
    competitor = FormulaFordCompetitor.query.get_or_404(competitor_id)
    
    if request.method == 'POST':
        try:
            # Update competitor details
            competitor.first_name = request.form.get('first_name')
            competitor.last_name = request.form.get('last_name')
            competitor.team_association = request.form.get('team_association')
            competitor.vehicle_make = request.form.get('vehicle_make')
            competitor.vehicle_type = request.form.get('vehicle_type')
            competitor.car_number = int(request.form.get('car_number'))

            db.session.commit()
            flash('Competitor updated successfully', 'success')
            return redirect(url_for('manage_formula_ford_competitors'))

        except ValueError:
            flash('Invalid car number format', 'error')
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating competitor: {str(e)}', 'error')
            
    return render_template('formula_ford/edit_competitor.html', competitor=competitor)

@app.route('/formula_ford/competitors/<int:competitor_id>/update', methods=['POST'])
@login_required
def update_formula_ford_competitor(competitor_id):
    competitor = FormulaFordCompetitor.query.get_or_404(competitor_id)
    
    try:
        # Update competitor details
        competitor.first_name = request.form.get('first_name')
        competitor.last_name = request.form.get('last_name')
        competitor.team_association = request.form.get('team_association')
        competitor.vehicle_make = request.form.get('vehicle_make')
        competitor.vehicle_type = request.form.get('vehicle_type')
        competitor.car_number = int(request.form.get('car_number'))

        db.session.commit()
        flash('Competitor updated successfully', 'success')
    except ValueError:
        flash('Invalid car number format', 'error')
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating competitor: {str(e)}', 'error')
        
    return redirect(url_for('manage_formula_ford_competitors'))

@app.route('/formula_ford/competitors/<int:competitor_id>/delete', methods=['POST'])
@login_required
def delete_formula_ford_competitor(competitor_id):
    try:
        competitor = FormulaFordCompetitor.query.get_or_404(competitor_id)
        
        # Check if competitor is referenced in any events
        event_entries = FormulaFordEventEntry.query.filter_by(competitor_id=competitor_id).all()
        if event_entries:
            # Delete associated event entries first
            for entry in event_entries:
                db.session.delete(entry)
                
        # Check for technical checks
        tech_checks = FormulaFordTechnicalCheck.query.filter_by(competitor_id=competitor_id).all()
        if tech_checks:
            for check in tech_checks:
                db.session.delete(check)
                
        # Check for tyre checks
        tyre_checks = FormulaFordTyreCheck.query.filter_by(competitor_id=competitor_id).all()
        if tyre_checks:
            for check in tyre_checks:
                db.session.delete(check)
        
        # Now delete the competitor
        db.session.delete(competitor)
        db.session.commit()
        
        flash(f'Competitor {competitor.first_name} {competitor.last_name} (Car #{competitor.car_number}) deleted successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting competitor: {str(e)}', 'error')
        
    return redirect(url_for('manage_formula_ford_competitors'))

@app.route('/formula_ford/manage_competitors_table', methods=['GET', 'POST'])
@login_required
def manage_formula_ford_competitors_table():
    if request.method == 'POST':
        try:
            # RAW REQUEST DEBUG INFO - Get and log the raw content
            print("\n=== RAW REQUEST DATA ===")
            print(f"Request method: {request.method}")
            print(f"Content type: {request.content_type}")
            print(f"Request content length: {request.headers.get('Content-Length')}")
            
            # Print form data keys and a few values for debugging
            print("\nChecking all possible storage locations:")
            print(f"request.form: {list(request.form.keys())}")
            print(f"request.args: {list(request.args.keys())}")
            print(f"request.json: {request.get_json(silent=True)}")
            print(f"request.values: {list(request.values.keys())}")
            
            # Enhanced debugging at the start
            print("\n=== COMPETITORS TABLE FORM SUBMISSION ===")
            print(f"Request method: {request.method}")
            print(f"Content type: {request.content_type}")
            print(f"Headers: {dict(request.headers)}")
            print(f"CSRF Token in form: {request.form.get('csrf_token')}")
            print(f"Current session: {dict(session)}")
            
            # Debug: Print all form data
            print("\n=== TABLE FORM DATA RECEIVED ===")
            print(f"Form keys: {list(request.form.keys())}")
            for key, value in request.form.items():
                print(f"{key}: {value}")
                
            # Get form data arrays for new competitors
            # Use getlist to get all occurrences of each field
            new_first_names = request.form.getlist('new_first_name[]')
            new_last_names = request.form.getlist('new_last_name[]')
            new_team_associations = request.form.getlist('new_team_association[]')
            new_car_numbers = request.form.getlist('new_car_number[]')
            
            # Handle vehicle makes (considering the dropdown and text input)
            vehicle_make_selects = request.form.getlist('vehicle_make_select[]')
            new_vehicle_makes_inputs = request.form.getlist('new_vehicle_make[]')
            
            # Process vehicle makes: if selection is "other", use the text input, otherwise use the dropdown value
            new_vehicle_makes = []
            for i in range(len(new_first_names)):
                # Make sure we don't go out of bounds
                if i < len(vehicle_make_selects) and vehicle_make_selects[i]:
                    if vehicle_make_selects[i] == 'other':
                        # Use the text input value for "other"
                        if i < len(new_vehicle_makes_inputs) and new_vehicle_makes_inputs[i]:
                            new_vehicle_makes.append(new_vehicle_makes_inputs[i])
                        else:
                            new_vehicle_makes.append('')
                    else:
                        # Use the dropdown selection for standard makes
                        new_vehicle_makes.append(vehicle_make_selects[i])
                elif i < len(new_vehicle_makes_inputs):
                    new_vehicle_makes.append(new_vehicle_makes_inputs[i])
                else:
                    new_vehicle_makes.append('')
            
            # Get vehicle types, ensuring we have enough values
            new_vehicle_types = request.form.getlist('new_vehicle_type[]')
            # Pad the array if needed to match the length of other arrays
            while len(new_vehicle_types) < len(new_first_names):
                new_vehicle_types.append('')
            
            print(f"\nParsed data:")
            print(f"First names: {new_first_names}")
            print(f"Last names: {new_last_names}")
            print(f"Team associations: {new_team_associations}")
            print(f"Vehicle makes: {new_vehicle_makes}")
            print(f"Vehicle types: {new_vehicle_types}")
            print(f"Car numbers: {new_car_numbers}")
            
            success_count = 0
            error_count = 0
            errors = []
            added_competitors = []
            
            # Process each row of data
            for i in range(len(new_first_names)):
                try:
                    # Ensure we have valid indexes for all arrays
                    if i >= len(new_last_names) or i >= len(new_car_numbers) or i >= len(new_vehicle_types) or i >= len(new_vehicle_makes):
                        print(f"Skipping row {i+1} due to missing data (array index mismatch)")
                        continue
                        
                    # Skip empty rows (check if essential fields are empty)
                    if (not new_first_names[i].strip() or 
                        not new_last_names[i].strip() or 
                        not new_car_numbers[i].strip() or
                        not new_vehicle_makes[i].strip() or
                        not new_vehicle_types[i].strip()):
                        print(f"Skipping empty row {i+1}")
                        continue
                    
                    # Parse and validate car number
                    try:
                        car_number = int(new_car_numbers[i])
                    except ValueError:
                        error_msg = f"Invalid car number format: {new_car_numbers[i]} (Row {i+1})"
                        print(error_msg)
                        errors.append(error_msg)
                        error_count += 1
                        continue
                    
                    # Check for duplicate car number
                    existing = FormulaFordCompetitor.query.filter_by(car_number=car_number).first()
                    if existing:
                        error_msg = f"Car number {car_number} already exists (Row {i+1})"
                        print(error_msg)
                        errors.append(error_msg)
                        error_count += 1
                        continue
                    
                    # Create new competitor
                    team_assoc = new_team_associations[i] if i < len(new_team_associations) else None
                    
                    competitor = FormulaFordCompetitor(
                        first_name=new_first_names[i],
                        last_name=new_last_names[i],
                        team_association=team_assoc,
                        vehicle_make=new_vehicle_makes[i],
                        vehicle_type=new_vehicle_types[i],
                        car_number=car_number
                    )
                    
                    db.session.add(competitor)
                    print(f"Added competitor to session: {new_first_names[i]} {new_last_names[i]} (car #{car_number})")
                    success_count += 1
                    added_competitors.append({
                        'name': f"{new_first_names[i]} {new_last_names[i]}",
                        'car_number': car_number,
                        'vehicle': f"{new_vehicle_makes[i]} {new_vehicle_types[i]}"
                    })
                    
                except Exception as e:
                    error_msg = f"Error processing competitor (Row {i+1}): {str(e)}"
                    print(error_msg)
                    errors.append(error_msg)
                    error_count += 1
            
            # Commit changes if any competitors were successfully added
            if success_count > 0:
                try:
                    print(f"Attempting to commit {success_count} competitors to database")
                    db.session.commit()
                    print("Database commit successful")
                    
                    # Set a flash message for when the page redirects
                    flash(f'Successfully added {success_count} competitors!', 'success')
                    
                    # Return a JSON response for AJAX requests
                    return jsonify({
                        'status': 'success',
                        'message': f'Successfully added {success_count} competitors!',
                        'redirect': url_for('manage_formula_ford_competitors_table'),
                        'added_competitors': added_competitors
                    })
                    
                except Exception as e:
                    db.session.rollback()
                    print(f"Database commit failed: {str(e)}")
                    error_msg = f"Database error: {str(e)}"
                    errors.append(error_msg)
                    
                    return jsonify({
                        'status': 'error',
                        'message': 'Failed to save competitors to database',
                        'error': str(e),
                        'errors': errors
                    }), 500
            else:
                db.session.rollback()
                print("No valid competitors to add")
                
                if error_count > 0:
                    return jsonify({
                        'status': 'error',
                        'message': 'No valid competitors submitted',
                        'errors': errors
                    }), 400
                else:
                    return jsonify({
                        'status': 'warning',
                        'message': 'No competitors to add - please fill in all required fields'
                    }), 400
            
        except Exception as e:
            db.session.rollback()
            print(f"Unhandled error: {str(e)}")
            import traceback
            traceback.print_exc()
            
            return jsonify({
                'status': 'error', 
                'message': f'Unhandled error: {str(e)}',
                'traceback': traceback.format_exc()
            }), 500
    
    # Handle GET requests
    competitors = FormulaFordCompetitor.query.order_by(FormulaFordCompetitor.car_number).all()
    return render_template('formula_ford/manage_competitors_table.html', competitors=competitors)

# Add a debug route at the end of the file, before the "if __name__ == '__main__'" line

# CSRF Debug Route
@app.route('/debug_csrf')
def debug_csrf():
    """Debug route to test CSRF token generation and session handling."""
    # Generate a new CSRF token
    csrf_token = generate_csrf()
    
    # Get detailed session info
    session_data = {k: str(v) for k, v in session.items()}
    
    # Return debug information
    debug_info = {
        'csrf_token': csrf_token,
        'session_data': session_data,
        'session_cookie_name': app.config.get('SESSION_COOKIE_NAME'),
        'session_cookie_secure': app.config.get('SESSION_COOKIE_SECURE'),
        'session_cookie_httponly': app.config.get('SESSION_COOKIE_HTTPONLY'),
        'request_cookies': {k: str(v) for k, v in request.cookies.items()},
        'flask_wtf_version': getattr(csrf, '__version__', 'unknown')
    }
    
    return render_template('debug_csrf.html', debug_info=debug_info, csrf_token=csrf_token)

# CSRF Debug Test Route
@app.route('/debug_csrf_test', methods=['POST'])
def debug_csrf_test():
    """Test route to verify CSRF token validation."""
    try:
        # Output detailed information about the request
        print("\n=== DEBUG CSRF TEST ===")
        print(f"POST data: {request.form}")
        csrf_token = request.form.get('csrf_token')
        print(f"CSRF token received: {csrf_token}")
        
        # Try to validate the CSRF token
        is_valid = validate_csrf(csrf_token)
        print(f"CSRF token is valid: {is_valid}")
        
        # Return a simple response
        if is_valid:
            return "CSRF token is valid! Test successful."
        else:
            return "CSRF token is NOT valid! Test failed."
    except Exception as e:
        # If an exception occurs, return details
        error_details = f"Error during CSRF test: {str(e)}\n{traceback.format_exc()}"
        print(error_details)
        return f"<pre>{error_details}</pre>"

# Add a simple login test route without CSRF protection
@app.route('/test_login', methods=['GET', 'POST'])
@csrf.exempt  # Exempt this route from CSRF protection for testing
def test_login():
    if request.method == 'POST':
        print("\n=== TEST LOGIN DEBUG START ===")
        print("TEST LOGIN: POST request received")
        print(f"TEST LOGIN: Form data: {request.form}")
        
        username = request.form.get('username')
        password = request.form.get('password')
        
        user = User.query.filter_by(username=username).first()
        print(f"TEST LOGIN: User found: {user is not None}")
        
        if user and check_password(password, user.password):
            login_user(user)
            print("TEST LOGIN: Login successful")
            print("=== TEST LOGIN DEBUG END ===\n")
            return redirect(url_for('index'))
        else:
            print("TEST LOGIN: Login failed")
            print("=== TEST LOGIN DEBUG END ===\n")
            flash("Invalid username or password", "danger")
            
    return render_template('test_login.html')

@app.route('/formula_ford/events/<int:event_id>/technical_requirements')
@login_required
def event_technical_requirements(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    requirements = EventTechnicalRequirements.query.filter_by(event_id=event_id).first()
    entries = FormulaFordEventEntry.query.filter_by(event_id=event_id).all()
    
    # Get all technical records for this event
    records = CompetitorTechnicalRecord.query.filter(
        CompetitorTechnicalRecord.entry_id.in_([entry.id for entry in entries])
    ).all() if entries else []
    
    # Create a dictionary to easily access technical records by entry ID
    records_by_entry = {record.entry_id: record for record in records}
    
    # Attach technical record to each entry
    for entry in entries:
        entry.technical_record = records_by_entry.get(entry.id)
    
    return render_template('formula_ford/event_technical_requirements.html', 
                           event=event, 
                           requirements=requirements, 
                           entries=entries)


@app.route('/formula_ford/events/<int:event_id>/technical_requirements/update', methods=['POST'])
@login_required
def update_event_technical_requirements(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    
    # Check if requirements already exist
    requirements = EventTechnicalRequirements.query.filter_by(event_id=event_id).first()
    
    if not requirements:
        # Create new requirements
        requirements = EventTechnicalRequirements(
            event_id=event_id,
            min_weight_kg=request.form.get('min_weight_kg'),
            height_requirement=request.form.get('height_requirement'),
            fuel_requirement=request.form.get('fuel_requirement'),
            safety_equipment_requirement=request.form.get('safety_equipment_requirement'),
            notes=request.form.get('notes'),
            created_by=request.form.get('created_by'),
            date_created=datetime.now()
        )
        db.session.add(requirements)
        flash('Technical requirements added successfully.', 'success')
    else:
        # Update existing requirements
        requirements.min_weight_kg = request.form.get('min_weight_kg')
        requirements.height_requirement = request.form.get('height_requirement')
        requirements.fuel_requirement = request.form.get('fuel_requirement')
        requirements.safety_equipment_requirement = request.form.get('safety_equipment_requirement')
        requirements.notes = request.form.get('notes')
        requirements.created_by = request.form.get('created_by')
        flash('Technical requirements updated successfully.', 'success')
    
    db.session.commit()
    return redirect(url_for('event_technical_requirements', event_id=event_id))


@app.route('/formula_ford/events/<int:event_id>/technical_records')
@login_required
def event_technical_records(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    requirements = EventTechnicalRequirements.query.filter_by(event_id=event_id).first()
    entries = FormulaFordEventEntry.query.filter_by(event_id=event_id).all()
    
    # Get all technical records for this event
    records = CompetitorTechnicalRecord.query.filter(
        CompetitorTechnicalRecord.entry_id.in_([entry.id for entry in entries])
    ).all() if entries else []
    
    # Create a dictionary to easily access technical records by entry ID
    records_by_entry = {record.entry_id: record for record in records}
    
    # Attach technical record to each entry
    for entry in entries:
        entry.technical_record = records_by_entry.get(entry.id)
    
    return render_template('formula_ford/event_competitor_technical_records.html', 
                           event=event, 
                           requirements=requirements, 
                           entries=entries,
                           competitors=True if entries else False)


@app.route('/formula_ford/events/<int:event_id>/technical_records/update', methods=['POST'])
@login_required
def update_competitor_technical_record(event_id):
    entry_id = request.form.get('entry_id')
    competitor_id = request.form.get('competitor_id')
    
    # Check if a record already exists
    record = CompetitorTechnicalRecord.query.filter_by(entry_id=entry_id).first()
    
    if not record:
        # Create new record
        record = CompetitorTechnicalRecord(
            entry_id=entry_id,
            competitor_id=competitor_id,
            weight=request.form.get('weight'),
            height_check='height_check' in request.form,
            fuel_check='fuel_check' in request.form,
            safety_equipment_check='safety_equipment_check' in request.form,
            notes=request.form.get('notes'),
            inspector_name=request.form.get('inspector_name'),
            check_date=datetime.now()
        )
        db.session.add(record)
        flash('Technical record added successfully.', 'success')
    else:
        # Update existing record
        record.weight = request.form.get('weight')
        record.height_check = 'height_check' in request.form
        record.fuel_check = 'fuel_check' in request.form
        record.safety_equipment_check = 'safety_equipment_check' in request.form
        record.notes = request.form.get('notes')
        record.inspector_name = request.form.get('inspector_name')
        record.check_date = datetime.now()
        flash('Technical record updated successfully.', 'success')
    
    db.session.commit()
    return redirect(url_for('event_technical_records', event_id=event_id))


@app.route('/formula_ford/events/<int:event_id>/technical_records/batch', methods=['POST'])
@login_required
def batch_technical_check(event_id):
    # Get form data
    batch_height_check = 'batch_height_check' in request.form
    batch_fuel_check = 'batch_fuel_check' in request.form
    batch_safety_equipment_check = 'batch_safety_equipment_check' in request.form
    batch_notes = request.form.get('batch_notes')
    batch_inspector_name = request.form.get('batch_inspector_name')
    batch_scope = request.form.get('batch_scope', 'all')
    
    # Get all entries for this event
    entries = FormulaFordEventEntry.query.filter_by(event_id=event_id).all()
    
    # Get existing records if needed
    if batch_scope == 'unchecked':
        existing_records = CompetitorTechnicalRecord.query.filter(
            CompetitorTechnicalRecord.entry_id.in_([entry.id for entry in entries])
        ).all() if entries else []
        existing_entry_ids = [record.entry_id for record in existing_records]
        entries = [entry for entry in entries if entry.id not in existing_entry_ids]
    
    # Apply batch check to all required entries
    count = 0
    for entry in entries:
        # Check if a record already exists
        record = CompetitorTechnicalRecord.query.filter_by(entry_id=entry.id).first()
        
        if not record:
            # Create new record
            record = CompetitorTechnicalRecord(
                entry_id=entry.id,
                competitor_id=entry.competitor_id,
                height_check=batch_height_check,
                fuel_check=batch_fuel_check,
                safety_equipment_check=batch_safety_equipment_check,
                notes=batch_notes,
                inspector_name=batch_inspector_name,
                check_date=datetime.now()
            )
            db.session.add(record)
        else:
            # Update existing record
            record.height_check = batch_height_check
            record.fuel_check = batch_fuel_check
            record.safety_equipment_check = batch_safety_equipment_check
            record.notes = batch_notes
            record.inspector_name = batch_inspector_name
            record.check_date = datetime.now()
        
        count += 1
    
    db.session.commit()
    flash(f'Batch technical check applied to {count} competitors.', 'success')
    return redirect(url_for('event_technical_records', event_id=event_id))


@app.route('/formula_ford/events/<int:event_id>/tyre_requirements')
@login_required
def event_tyre_requirements(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    requirements = EventTyreRequirements.query.filter_by(event_id=event_id).first()
    entries = FormulaFordEventEntry.query.filter_by(event_id=event_id).all()
    
    # Get all tyre records for this event
    records = CompetitorTyreRecord.query.filter_by(event_id=event_id).all()
    
    return render_template('formula_ford/event_tyre_requirements.html', 
                           event=event, 
                           requirements=requirements, 
                           records=records)


@app.route('/formula_ford/events/<int:event_id>/tyre_requirements/update', methods=['POST'])
@login_required
def update_event_tyre_requirements(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    
    # Check if requirements already exist
    requirements = EventTyreRequirements.query.filter_by(event_id=event_id).first()
    
    if not requirements:
        # Create new requirements
        requirements = EventTyreRequirements(
            event_id=event_id,
            allowed_practice_brands=request.form.get('allowed_practice_brands'),
            allowed_practice_compounds=request.form.get('allowed_practice_compounds'),
            allowed_race_brands=request.form.get('allowed_race_brands'),
            allowed_race_compounds=request.form.get('allowed_race_compounds'),
            max_sets_allowed=request.form.get('max_sets_allowed'),
            notes=request.form.get('notes'),
            created_by=request.form.get('created_by'),
            date_created=datetime.now()
        )
        db.session.add(requirements)
        flash('Tyre requirements added successfully.', 'success')
    else:
        # Update existing requirements
        requirements.allowed_practice_brands = request.form.get('allowed_practice_brands')
        requirements.allowed_practice_compounds = request.form.get('allowed_practice_compounds')
        requirements.allowed_race_brands = request.form.get('allowed_race_brands')
        requirements.allowed_race_compounds = request.form.get('allowed_race_compounds')
        requirements.max_sets_allowed = request.form.get('max_sets_allowed')
        requirements.notes = request.form.get('notes')
        requirements.created_by = request.form.get('created_by')
        flash('Tyre requirements updated successfully.', 'success')
    
    db.session.commit()
    return redirect(url_for('event_tyre_requirements', event_id=event_id))


@app.route('/formula_ford/events/<int:event_id>/tyre_records')
@login_required
def event_tyre_records(event_id):
    event = FormulaFordEvent.query.get_or_404(event_id)
    requirements = EventTyreRequirements.query.filter_by(event_id=event_id).first()
    entries = FormulaFordEventEntry.query.filter_by(event_id=event_id).all()
    
    # Get all tyre records for this event
    records = CompetitorTyreRecord.query.filter_by(event_id=event_id).all()
    
    # Create a dictionary to easily access tyre records by competitor ID
    records_by_competitor = {record.competitor_id: record for record in records}
    
    # Attach tyre record to each entry
    for entry in entries:
        entry.tyre_record = records_by_competitor.get(entry.competitor_id)
    
    return render_template('formula_ford/event_competitor_tyre_records.html', 
                           event=event, 
                           requirements=requirements, 
                           entries=entries,
                           competitors=True if entries else False)


@app.route('/formula_ford/events/<int:event_id>/tyre_records/update', methods=['POST'])
@login_required
def update_competitor_tyre_record(event_id):
    entry_id = request.form.get('entry_id')
    competitor_id = request.form.get('competitor_id')
    
    # Process the form data
    practice_tyre_brand = request.form.get('practice_tyre_brand')
    if practice_tyre_brand == 'Other':
        practice_tyre_brand = request.form.get('practice_other_brand')
    
    practice_tyre_compound = request.form.get('practice_tyre_compound')
    if practice_tyre_compound == 'Other':
        practice_tyre_compound = request.form.get('practice_other_compound')
    
    race_tyre_brand = request.form.get('race_tyre_brand')
    if race_tyre_brand == 'Other':
        race_tyre_brand = request.form.get('race_other_brand')
    
    race_tyre_compound = request.form.get('race_tyre_compound')
    if race_tyre_compound == 'Other':
        race_tyre_compound = request.form.get('race_other_compound')
    
    # Check if a record already exists
    record = CompetitorTyreRecord.query.filter_by(event_id=event_id, competitor_id=competitor_id).first()
    
    if not record:
        # Create new record
        record = CompetitorTyreRecord(
            event_id=event_id,
            competitor_id=competitor_id,
            practice_tyre_brand=practice_tyre_brand,
            practice_tyre_compound=practice_tyre_compound,
            practice_tyre_serial_numbers=request.form.get('practice_tyre_serial_numbers'),
            race_tyre_brand=race_tyre_brand,
            race_tyre_compound=race_tyre_compound,
            race_tyre_serial_numbers=request.form.get('race_tyre_serial_numbers'),
            notes=request.form.get('notes'),
            inspector_name=request.form.get('inspector_name'),
            check_date=datetime.now()
        )
        db.session.add(record)
        flash('Tyre record added successfully.', 'success')
    else:
        # Update existing record
        record.practice_tyre_brand = practice_tyre_brand
        record.practice_tyre_compound = practice_tyre_compound
        record.practice_tyre_serial_numbers = request.form.get('practice_tyre_serial_numbers')
        record.race_tyre_brand = race_tyre_brand
        record.race_tyre_compound = race_tyre_compound
        record.race_tyre_serial_numbers = request.form.get('race_tyre_serial_numbers')
        record.notes = request.form.get('notes')
        record.inspector_name = request.form.get('inspector_name')
        record.check_date = datetime.now()
        flash('Tyre record updated successfully.', 'success')
    
    db.session.commit()
    return redirect(url_for('event_tyre_records', event_id=event_id))

    return redirect(url_for('manage_formula_ford_events'))

# Run the application
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5001, debug=True)  # Enable debug

